<!DOCTYPE html>
<html>
<head>
    <title>Gradient Based Polyline in Leaflet</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
        body, html {
            height: 100%;
            margin: 0;
        }
        #mapid {
            width: 100vw; /* ビューポートの幅全体 */
            height: 100vh; /* ビューポートの高さ全体 */
            position: absolute;
        }
        #gpx-file-input {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="mapid"></div>
    <input type="file" id="gpx-file-input" accept=".gpx">
    <script>
        var mymap = L.map('mapid').setView([36.3428, 137.6478], 6);
        // 国土地理院のタイルレイヤーを地図に追加
        L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
            attribution: '地図データ &copy; <a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a>'
        }).addTo(mymap);

        // GPXファイルをアップロードするための関数
        function handleFileUpload(file) {
            var reader = new FileReader();
            reader.onload = function(e) {
                var parser = new DOMParser();
                var doc = parser.parseFromString(e.target.result, "application/xml");
                var trkpts = doc.querySelectorAll("trkpt");
                var data = [];
                trkpts.forEach(function(pt) {
                    var lat = parseFloat(pt.getAttribute('lat'));
                    var lon = parseFloat(pt.getAttribute('lon'));
                    var ele = parseFloat(pt.querySelector('ele').textContent);
                    data.push([lat, lon, ele]);
                });

                var latlngs = data.map(function(item) {
                    return [item[0], item[1]]; // latとlonのみを抽出
                });

                if (latlngs.length > 0) {
                    var polyline = L.polyline(latlngs);
                    mymap.fitBounds(polyline.getBounds());
                }
                
                var segments = calculateGradients(data);

                segments.forEach(function(segment) {
                    var color = getColorForGradient(segment.gradient);
                    var latlngs = [[segment.start[0], segment.start[1]], [segment.end[0], segment.end[1]]];
                    L.polyline(latlngs, {color: color}).addTo(mymap);
                });
            };
            reader.readAsText(file);
        }

        // ファイルアップロードイベント
        document.getElementById('gpx-file-input').addEventListener('change', function(e) {
            handleFileUpload(e.target.files[0]);
        });

        // ドラッグ&ドロップイベント
        mymap.getContainer().addEventListener('dragover', function(e) {
            e.preventDefault(); // デフォルトの挙動を防ぐ
        });
        mymap.getContainer().addEventListener('drop', function(e) {
            e.preventDefault();
            var file = e.dataTransfer.files[0];
            if (file && file.type === "application/gpx+xml") {
                handleFileUpload(file);
            }
        });

        function calculateGradients(data) {
            var segments = [];
            for (var i = 1; i < data.length; i++) {
                var start = data[i-1];
                var end = data[i];
                var distance = getDistance(start[0], start[1], end[0], end[1]);
                var elevationChange = end[2] - start[2];
                var gradient = Math.atan(elevationChange / distance) * (180 / Math.PI);
                segments.push({
                    start: start,
                    end: end,
                    gradient: gradient
                });
            }
            return segments;
        }

        function getColorForGradient(gradient) {
            if (Math.abs(gradient) > 30) return 'red';
            else if (Math.abs(gradient) > 15) return 'yellow';
            else return 'green';
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371e3; // meters
            var φ1 = lat1 * Math.PI/180;
            var φ2 = lat2 * Math.PI/180;
            var Δφ = (lat2-lat1) * Math.PI/180;
            var Δλ = (lon2-lon1) * Math.PI/180;

            var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // in meters
        }
    </script>
</body>
</html>
