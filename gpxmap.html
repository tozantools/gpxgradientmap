<!DOCTYPE html>
<html>
<head>
    <title>Gradient Based Polyline in Leaflet</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
        #mapid {
            width: 100vw; /* ビューポートの幅全体 */
            height: 100vh; /* ビューポートの高さ全体 */
            position: absolute;
        }
    </style>
</head>
<body>
    <div id="mapid"></div>
    <input type="file" id="gpx-file-input" accept=".gpx" style="position: absolute; bottom: 10px; left: 10px; z-index: 1000;">
    <script>
        var mymap = L.map('mapid');
        // 国土地理院のタイルレイヤーを地図に追加
        L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
            attribution: '地図データ &copy; <a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a>'
        }).addTo(mymap);

        document.getElementById('gpx-file-input').addEventListener('change', function(e) {
            var file = e.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    var parser = new DOMParser();
                    var doc = parser.parseFromString(e.target.result, "application/xml");
                    var trkpts = doc.querySelectorAll("trkpt");
                    var data = [];
                    trkpts.forEach(function(pt) {
                        var lat = parseFloat(pt.getAttribute('lat'));
                        var lon = parseFloat(pt.getAttribute('lon'));
                        var ele = parseFloat(pt.querySelector('ele').textContent);
                        data.push([lat, lon, ele]);
                    });

                    // 最初の地点を地図の中心に設定
                    if (data.length > 0) {
                        mymap.setView([data[0][0], data[0][1]], 13);
                    }

                    var segments = calculateGradients(data);

                    segments.forEach(function(segment) {
                        var color = getColorForGradient(segment.gradient);
                        var latlngs = [[segment.start[0], segment.start[1]], [segment.end[0], segment.end[1]]];
                        L.polyline(latlngs, {color: color}).addTo(mymap);
                    });
                };
                reader.readAsText(file);
            }
        });

        function calculateGradients(data) {
            var segments = [];
            for (var i = 1; i < data.length; i++) {
                var start = data[i-1];
                var end = data[i];
                var distance = getDistance(start[0], start[1], end[0], end[1]);
                var elevationChange = end[2] - start[2];
                var gradient = Math.atan(elevationChange / distance) * (180 / Math.PI);
                segments.push({
                    start: start,
                    end: end,
                    gradient: gradient
                });
            }
            return segments;
        }

        function getColorForGradient(gradient) {
            if (Math.abs(gradient) > 30) return 'red';
            else if (Math.abs(gradient) > 15) return 'yellow';
            else return 'green';
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371e3; // meters
            var φ1 = lat1 * Math.PI/180;
            var φ2 = lat2 * Math.PI/180;
            var Δφ = (lat2-lat1) * Math.PI/180;
            var Δλ = (lon2-lon1) * Math.PI/180;

            var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // in meters
        }
    </script>
</body>
</html>
