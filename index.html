<!DOCTYPE html>
<html>
<head>
    <title>Gradient Based Polyline in Leaflet</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/geographiclib-geodesic@2.0.0/geographiclib-geodesic.min.js"></script> -->
    <style>
        body, html {
            height: 100%;
            margin: 0;
        }
        #mapid {
            width: 100vw; /* ビューポートの幅全体 */
            height: 100vh; /* ビューポートの高さ全体 */
            position: absolute;
        }
        #gpx-file-input {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }
        .custom-attribution {
            background: rgba(255, 255, 255, 0.9); /* 半透明の白 */
            border-radius: 5px; /* 角の丸み */
            box-shadow: 0 1px 5px rgba(0,0,0,0.4); /* 影の追加 */
            margin: 10px; /* 余白 */
            padding: 5px 10px; /* 内側の余白 */
            font-size: 12px; /* フォントサイズ */
        }
    </style>
</head>
<body>
    <div id="mapid"></div>
    <input type="file" id="gpx-file-input" accept=".gpx">
    <script>
        var mymap = L.map('mapid').setView([36.3428, 137.6478], 6);
        // 国土地理院のタイルレイヤーを地図に追加
        var stdLayer = new L.TileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png');
        var hillshadeLayer = new L.TileLayer('https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png');
        mymap.addLayer(stdLayer);

        L.control.layers({"地理院地図": stdLayer, "陰影起伏図": hillshadeLayer}).addTo(mymap);

        // カスタムattributionコントロールを作成
        var customAttribution = L.control({position: 'topright'});
        customAttribution.onAdd = function(map) {
            var div = L.DomUtil.create('div', 'custom-attribution');
            div.innerHTML = '<span>地図データ &copy; <a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a></span>';
            return div;
        };
        customAttribution.addTo(mymap);

        // GPXファイルをアップロードするための関数
        function handleFileUpload(file) {
            var reader = new FileReader();
            reader.onload = function(e) {
                var parser = new DOMParser();
                var doc = parser.parseFromString(e.target.result, "application/xml");
                var trkpts = doc.querySelectorAll("trkpt");
                var data = [];
                trkpts.forEach(function(pt) {
                    var lat = parseFloat(pt.getAttribute('lat'));
                    var lon = parseFloat(pt.getAttribute('lon'));
                    var ele = parseFloat(pt.querySelector('ele').textContent);
                    data.push([lat, lon, ele]);
                });

                var latlngs = data.map(function(item) {
                    return [item[0], item[1]]; // latとlonのみを抽出
                });

                if (latlngs.length > 0) {
                    var polyline = L.polyline(latlngs);
                    mymap.fitBounds(polyline.getBounds());
                }
                
                var segments = calculateGradients(data);

                segments.forEach(function(segment) {
                    var color = getColorForGradient(segment.gradient);
                    var latlngs = [[segment.start[0], segment.start[1]], [segment.end[0], segment.end[1]]];
                    L.polyline(latlngs, {color: color}).addTo(mymap);
                });
            };
            reader.readAsText(file);
        }

        // ファイルアップロードイベント
        document.getElementById('gpx-file-input').addEventListener('change', function(e) {
            handleFileUpload(e.target.files[0]);
        });

        // ドラッグ&ドロップイベント
        mymap.getContainer().addEventListener('dragover', function(e) {
            e.preventDefault(); // デフォルトの挙動を防ぐ
        });
        mymap.getContainer().addEventListener('drop', function(e) {
            e.preventDefault();
            var file = e.dataTransfer.files[0];
            if (file && file.type === "application/gpx+xml") {
                handleFileUpload(file);
            }
        });

        function calculateGradients(data) {
            var segments = [];
            for (var i = 1; i < data.length; i++) {
                var start = data[i-1];
                var end = data[i];
                var distance = getDistance(start[0], start[1], end[0], end[1]);
                // var distance = getDistanceVincenty(start[0], start[1], end[0], end[1]);
                // var distance = window.geodesic.Geodesic.WGS84.Inverse(start[0], start[1], end[0], end[1]).s12;
                var elevationChange = end[2] - start[2];
                var gradient = Math.atan(elevationChange / distance) * (180 / Math.PI);
                segments.push({
                    start: start,
                    end: end,
                    gradient: gradient
                });
            }
            return segments;
        }

        function getColorForGradient(gradient) {
            if (Math.abs(gradient) > 30) return 'red';
            else if (Math.abs(gradient) > 15) return 'yellow';
            else return 'green';
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            var R = 6371e3; // meters
            var φ1 = lat1 * Math.PI/180;
            var φ2 = lat2 * Math.PI/180;
            var Δφ = (lat2-lat1) * Math.PI/180;
            var Δλ = (lon2-lon1) * Math.PI/180;

            var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // in meters
        }

        function getDistanceVincenty(lat1, lon1, lat2, lon2) {
            var a = 6378137; // 地球の長半径 (meters)
            var f = 1 / 298.257223563; // 地球の扁平率 (WGS-84)
            var b = (1 - f) * a;
            var L = (lon2 - lon1) * Math.PI / 180;

            var U1 = Math.atan((1 - f) * Math.tan(lat1 * Math.PI / 180));
            var U2 = Math.atan((1 - f) * Math.tan(lat2 * Math.PI / 180));

            var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
            var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);

            var lambda = L, lambdaP, iterLimit = 100;
            var sinLambda, cosLambda, sinSigma, cosSigma, sigma, sinAlpha, cosSqAlpha, cos2SigmaM, C;
            do {
                sinLambda = Math.sin(lambda);
                cosLambda = Math.cos(lambda);
                sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) + 
                                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * 
                                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
                if (sinSigma == 0) return 0; // 同じ点

                cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
                sigma = Math.atan2(sinSigma, cosSigma);
                sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
                cosSqAlpha = 1 - sinAlpha * sinAlpha;
                cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
                if (isNaN(cos2SigmaM)) cos2SigmaM = 0; // 赤道上の場合
                C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
                lambdaP = lambda;
                lambda = L + (1 - C) * f * sinAlpha *
                        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
            } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);

            if (iterLimit == 0) return NaN; // 収束しない場合

            var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
            var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
            var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
            var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - 
                            B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));

            var s = b * A * (sigma - deltaSigma);

            return s; // 最終的な距離 (meters)
        }
    </script>
</body>
</html>
